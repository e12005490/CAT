"""
Tools for analyzing systems based on discrete logarithm hardness.
"""

from enum import Enum

from Cryptodome.PublicKey.ElGamal import ElGamalKey
from sympy.ntheory import n_order
from sympy.ntheory.factor_ import smoothness
from sympy.ntheory.primetest import isprime

import gmpy2


class Result(Enum):
    """Indicates that all checks passed successfully."""

    PROBABLY_SAFE = 0
    """
    Indicates that the given modulus is not a prime number. A non-prime modulus :code:`p` can be factored
    into prime factors :code:`q_i`, which allows you to solve the discrete logarithm problem
    in :math:`O(\sum_i e_i \sqrt(q_i))` using `Pohlig-Hellman decomposition`_.

    .. _`Pohlig-Hellman decomposition`: https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm
    """
    NON_PRIME_MODULUS = 1
    """
    Indicates that the given prime modulus is too small. "Smallness" is defined via a bound that is passed to
    the function returning this value and for the prime modulus to be "large enough" it has to be at least
    double the bit length of the given bound. This is due to the `Phollard Rho`_ algorithm and Shanks'
    `baby step-giant step`_ algorithm both being able to solve the discrete logarithm problem in
    :math:`O(\sqrt(q))`, where :math:`q` is the order of the group (and since the modulus :code:`p` is prime,
    the order of the group :math:`q=p-1`).

    .. _`Phollard Rho`: https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm
    .. _`baby step-giant step`: https://en.wikipedia.org/wiki/Baby-step_giant-step
    """
    SMALL_MODULUS = 2
    """
    Indicates that the order of the subgroup defined by a generator is non-prime.
    """
    NON_PRIME_SUBGROUP_ORDER = 3
    """
    Indicates that the order of the subgroup defined by a generator is too small. "Smallness" is defined via a bound
    that is passed to the function returning this value and for the subgroup's order to be "large enough" it has to
    be at least the bit length of the given bound.
    """
    SMALL_SUBGROUP = 4


def check_components(g, p, B=512):
    # type: (int, int, int) -> Result
    """
    Takes a modulus :attr:`p` and a generator :attr:`g` together with an optional bound :attr:`B` and
    checks various conditions that must hold for e.g. Diffie-Hellman Key Exchange. If one of these
    conditions is violated, the failing condition is returned as defined in :class:`Result`.

    The conditions that are verified are:
    * Is :attr:`p` a prime number?
    * Is the bit size of :attr:`p` greater than :code:`2*B`?
    * Is the order of group generated by :attr:`g` prime and greater than :attr:`B`?

    For further information on these conditions, you can refer to:
    * "On Diffie-Hellman Key Agreement with Short Exponents" by van Oorschot and Wiener
    * "Minding your p's and q's" by Anderson and Vaudenay
    * "Measuring small subgroup attacks against Diffie-Hellman" by Valenta, et.al.

    >>> result = check_components(2, 4)
    >>> result == Result.NON_PRIME_MODULUS
    True
    >>> result = check_components(2, 7)
    >>> result == Result.SMALL_MODULUS
    True
    >>> B=3
    >>> result = check_components(-1, 67, B)
    >>> result == Result.SMALL_SUBGROUP
    True

    :param g: A generator of a subgroup of the group generated by :attr:`p`.
    :param p: A prime number used as a modulus of a group.
    :param B: A bound that defines "largeness" or "smallness". I.e. :attr:`p` is said to be a "large" prime
              if it satisfies :code:`p > 2*B`. Whereas the bigges prime factor of :attr:`p-1` is said to be
              "large" if it is greater than :attr:`B`. Defaults to :code:`512`.
    :returns: A :class:`Result` specifing which attack could possibly used against the given components.
    """
    # Check if p is prime
    if not isprime(p):
        return Result.NON_PRIME_MODULUS
    # Check size of p
    if p.bit_length() < 2 * B:
        return Result.SMALL_MODULUS
    # Does g generate a subgroup of order at least `B`?
    q = n_order(g, p)
    if not isprime(q):
        return Result.NON_PRIME_SUBGROUP_ORDER
    if q < B:
        return Result.SMALL_SUBGROUP
    return Result.PROBABLY_SAFE
